/*

Now that we can declare tasks, it's time to think about the relationships
between tasks. For example, in a Java build, we can't JAR up our library
before compiling our sources. We model these relationships by task
dependencies and ordering.

We'll discuss three ways to configure the relationships between tasks:
`dependsOn`, `finalizedBy`, and `mustRunAfter`.

Task A `dependsOn` task B if task A can't do its work without task B having
done its work. To take a familiar example, when you're getting up in the
morning, you can't put on your shoes without putting on your socks first.
Let's declare and configure some tasks to represent this process.

*/

task putOnSocks {
    doLast {
        println "Putting on Socks."
    }
}

task putOnShoes {
    dependsOn "putOnSocks"
    doLast {
        println "Putting on Shoes."
    }
}

/*

One thing to note is that if you run `gradle tasks`, you won't see
`putOnSocks`. That's because Gradle assumes that `putOnSocks` exists only to
help `putOnShoes` do its job. You can still see the `putOnSocks` task by
running `gradle tasks --all`.

Task A is `finalizedBy` task B if every time task A runs, task B should be run
afterwards. To continue our example, every time you eat breakfast, you must
brush your teeth afterwards. Let's create those tasks, and declare the
relationship between them.

*/

task eatBreakfast {
    finalizedBy "brushYourTeeth"
    doLast{
        println "Om nom nom breakfast!"
    }
}

task brushYourTeeth {
    doLast {
        println "Brushie Brushie Brushie."
    }
}

/*

The use case for `mustRunAfter` is slightly less obvious. Say we have a long
running process that's unlikely to fail, like deploying some artifact to a
continuous integration server, and we also have a short running task that is
likely to fail, like running unit tests. Those two tasks don't have any
dependency relationship, but if we're running both, we would really like the
unit tests to run before the integration tests.

To continue our morning routine example, let's consider showering and putting
on a fragrance like perfume or cologne. Putting on a fragrance doesn't require
showering, and showering doesn't require putting on a fragrance, but if we're
going to both take a shower and also put on a fragrance, we should take the
shower first. Let's create those tasks and the relationship between them.

*/

task takeShower {
    doLast {
        println "Taking a shower."
    }
}

task putOnFragrance {
    shouldRunAfter "takeShower"
    doLast{
        println "Smellin' fresh!"
    }
}

/*

Now if we run `gradle putOnFragrance takeShower`, we see that we do the tasks
in the proper order.

Let's check out a few other things we can do with task dependencies. We can
depend on multiple tasks:

*/

task getReady {
    // Remember that when assigning a collection to a property, we need the
    // equals sign
    dependsOn = ["takeShower", "eatBreakfast", "putOnShoes"]
}

/*

Oops, we put on our shoes before taking a shower! Let's put in another
`mustRunAfter` relationship.

*/

putOnShoes.mustRunAfter takeShower

/*

One more advanced thing we can do is look at all the tasks in the project and
decide which ones we want to depend on. Let's make a task called `getEquipped`
that depends on every task that starts with "putOn".

*/

task getEquipped {
    dependsOn tasks.matching{ task -> task.name.startsWith("putOn")}
    doLast {
        println "All geared up!"
    }
}

/*

You don't need to understand all the Groovy and Gradle in that last example
quite yet. We just wanted to show off some of the power of Gradle. This is the
sort of thing that's difficult or impossible hard to do with other build
tools. For more information about tasks, check out this section of the Gradle
user guide for more info:

    https://docs.gradle.org/current/userguide/more_about_tasks.html

*/

/*
    In this series of exercises you'll be developing your knowledge of task
    dependencies. For these exercises we've provided some tasks for you.
    The tasks are all steps required to prepare a cup of coffee. The end
    result is to be able to prepare either a black or sweetened cup of
    coffee.

    Exercises:

    1. Configure dependencies for the "brew", "pour" and "drink" tasks
    such that to drink my coffee I must first pour it, and pouring my
    coffee requires me to first brew it.

    2. Configure dependencies for the "drink" and "addSweetener" tasks
    such that adding sweetener requires that my coffee be poured and if
    I am adding sweetener, I shouldn't drink my coffee until I've done
    so.

    3. Configure dependencies for the "blackCoffee" and "sweetCoffee"
    tasks so that both include drinking coffee, but the "sweetCoffee"
    task also includes the adding of sweetener to my coffee.

    4. Make sure your dependencies are correctly configured by running
    "blackCoffee" and "sweetCoffee" tasks individually.

    Hint: When considering an "optional" build step, such as sweetening
    my coffee, a "dependsOn" relationship isn't quite appropriate. I
    don't always want to add sweetener in my coffee, but IF I do, I
    should do so before I take a drink. Take a look at the Gradle user
    guide for more information.


*/

task brew {
    doLast {
        println "Brewing. Drip, drip, drip."
    }
}

task pour {
    dependsOn "brew"
    doLast {
        println "Pouring. Glug, glug, glug."
    }
}

task addSweetener {
    dependsOn "pour"
    finalizedBy "drink"
    doLast {
        println "Adding sweetener. Stir, stir, stir."
    }
}

task drink {
    dependsOn "pour"
    doLast {
        println "Drinking. Gulp, gulp, gulp."
    }
}

task blackCoffee {
    dependsOn "drink"
    doLast {
        println "Mmmm, bitter! just how I like it."
    }
//    dependsOn "drink"
}


task sweetCoffee {
    dependsOn "addSweetener"
    shouldRunAfter "drink"
    doLast {
        println "Mmmm, sweet! just how I like it."
    }

}
